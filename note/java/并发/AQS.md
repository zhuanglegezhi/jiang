```java
public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        lock.lock();
        try {
            // 业务逻辑
        } finally {
            lock.unlock();
        }
    }
```

- 这里将获取锁的过程放在了tyr块外，是为了防止在获取锁时发生异常，可以避免锁无故被释放。

  

![截屏2021-11-30 21.23.08](../../图片/截屏2021-11-30 21.23.08.png)



- 锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节
- 同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。
- 锁和同步器很好地隔离了使用者和实现者所需关注的领域





## 重入锁

公平 vs 非公平

公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。
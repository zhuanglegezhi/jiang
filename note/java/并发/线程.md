
# 生命周期

- 新建（New）

- 当程序使用new关键字创建了一个线程之后，该线程就处于 **新建状态**

  - 就绪（Runnable）

  - - 当线程对象调用了start()方法之后，该线程处于 **就绪状态**

    - 运行（Running）

    - - 当CPU开始调度处于 **就绪状态** 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 **运行状态**
      - 阻塞（Blocked）
      - - 处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 **阻塞状态**。
      - 等待（Waiting）
      - - 线程处于 **无限制等待状态**，等待一个特殊的事件来重新唤醒
      - 超时等待（TIMED_WAITING）
      - 死亡（Dead）
      - 中止（TERMINATED）
      - - 线程执行完毕后，进入终止（TERMINATED）状态。

    - 

      sleep()

    - - 通过sleep(millis)使线程进入休眠一段时间，**该方法在指定的时间内无法被唤醒，同时也不会释放对象锁**；

    - yield()

    - - **也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出CPU资源给其他的线程**
      - 但是和sleep()方法不同的是，**它不会进入到阻塞状态，而是进入到就绪状态**。
      - yield()方法只是让当前线程暂停一下，重新进入就绪线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：**当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行**。

    - Join()

    - - 线程的合并的含义就是 **将几个并行线程的线程合并为一个单线程执行**，应用场景是 **当一个线程必须等待另一个线程执行完毕才能执行时**，Thread类提供了join方法来完成这个功能，**注意，它不是静态方法**







# 等待/通知机制

## wait & notify & notifyAll

- wait & notify & notifyAll这三个都是Object类的方法。使用 wait，notify 和 notifyAll **前提是先获得调用对象的锁**。

- 调用 wait方法后，释放持有的对象锁，**线程状态有 Running 变为 Waiting**，并将当前线程放置到对象的**等待队列**；
- 调用notify 或者 notifyAll 方法后，**等待线程依旧不会从 wait 返回，需要调用 notify 的线程释放锁之后，等待线程才有机会从 wait 返回**
- notify 方法：**将等待队列的一个等待线程从等待队列种移到同步队列中** ，而 notifyAll 方法：**将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked**。





**同步队列 VS 等待队列**

- - **同步队列（锁池）**：假设线程A已经拥有了某个对象的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，**所以这些线程就进入了该对象的同步队列（锁池）中，这些线程状态为Blocked**。
  - **等待队列（等待池）**：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时 **线程A就进入到了该对象的等待队列（等待池）中，此时线程A状态为Waiting**。如果另外的一个线程调用了相同对象的notifyAll()方法，那么 **处于该对象的等待池中的线程就会全部进入该对象的同步队列（锁池）中，准备争夺锁的拥有权**。如果另外的一个线程调用了相同对象的notify()方法，那么 **仅仅有一个处于该对象的等待池中的线程（随机）会进入该对象的同步队列（锁池）**。

- 

  中断

- - 许多声明抛出InterruptedException的方法(例如Thread.sleep(long millis)方法)，这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的**中断标识位清除**，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false

- 
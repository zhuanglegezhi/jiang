#### 集群状态

- **`green`**：所有的主分片和副本分片都正常运行。

- **`yellow`**：所有的主分片都正常运行，但不是所有的副本分片都正常运行。

- **`red`**：有主分片没能正常运行



#### 分片

在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。



#### 路由

```
shard = hash(routing) % number_of_primary_shards
// 这就解释了为什么我们要在创建索引的时候就确定好主分片的数量 并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。
```



## 1、新建、索引、删除单个文档

![新建、索引和删除单个文档](https://www.elastic.co/guide/cn/elasticsearch/guide/2.x/images/elas_0402.png)


过程
> 1. 客户端向 `Node 1` 发送新建、索引或者删除请求。
>
> 2. 节点使用文档的 `_id` 确定文档属于分片 0 。请求会被转发到 `Node 3`，因为分片 0 的主分片目前被分配在 `Node 3` 上。
>
> 3. `Node 3` 在主分片上面执行请求。如果成功了，它将请求并行转发到 `Node 1` 和 `Node 2` 的副本分片上。一旦所有的副本分片都报告成功, `Node 3` 将向协调节点报告成功，协调节点向客户端报告成功。
>

在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。





## 2、取回一个文档

![取回单个文档](https://www.elastic.co/guide/cn/elasticsearch/guide/2.x/images/elas_0403.png)

> 1. 客户端向 `Node 1` 发送获取请求
> 2. 节点使用文档的 `_id` 来确定文档属于分片 `0` 。分片 `0` 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 `Node 2` 。
> 3. `Node 2` 将文档返回给 `Node 1` ，然后将文档返回给客户端。
>



在处理读取请求时，协调结点在每次请求的时候都会通过**轮询**所有的副本分片来达到**负载均衡**。


在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。



## 3、局部更新一个文档

![局部更新文档](https://www.elastic.co/guide/cn/elasticsearch/guide/2.x/images/elas_0404.png)

> 1. 客户端向 `Node 1` 发送更新请求。
> 1. 它将请求转发到主分片所在的 `Node 3` 。
> 3. `Node 3` 从**主分片**检索文档，修改 `_source` 字段中的 JSON ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 `retry_on_conflict` 次后放弃。（CAS）
> 4. 如果 `Node 3` 成功地更新文档，它将新版本的文档并行转发到 `Node 1` 和 `Node 2` 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， `Node 3` 向协调节点也返回成功，协调节点向客户端返回成功。


**基于文档的复制**

当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。



## 4、多文档模式

`mget` 和 `bulk` API 的模式类似于单文档模式。区别在于协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 *每个分片* 的多文档请求，并且将这些请求并行转发到每个参与节点。

### mget

![“使用 `mget` 取回多个文档”](../图片/elas_0405.png)

> 1. 客户端向 `Node 1` 发送 `mget` 请求。
> 1. `Node 1` 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复， `Node 1` 构建响应并将其返回给客户端。
可以对 `docs` 数组中每个文档设置 `routing` 参数。



### bulk 

![“使用 `bulk` 修改多个文档”](../图片/elas_0406.png)

> 1. 客户端向 `Node 1` 发送 `bulk` 请求。
> 1. `Node 1` 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。
> 3. 主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。
`bulk` API 还可以在整个批量请求的最顶层使用 `consistency` 参数，以及在每个请求中的元数据中使用 `routing` 参数。



**3、分布式检索**

**查询阶段**

![查询过程分布式搜索](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0901.png)

查询阶段包含以下三个步骤:

1. 客户端发送一个 `search` 请求到 `Node 3` ， `Node 3` 会创建一个大小为 `from + size` 的空优先队列。
2. `Node 3` 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 `from + size` 的本地有序优先队列中。
3. 每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 `Node 3` ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。



**取回阶段**

![分布式搜索的取回阶段](https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_0902.png)

分布式阶段由以下步骤构成：

1. 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 `GET` 请求。协调节点给持有相关文档的每个分片创建一个 [multi-get request](https://www.elastic.co/guide/cn/elasticsearch/guide/current/distrib-multi-doc.html) ，并发送请求给同样处理查询阶段的分片副本。
2. 每个分片加载并 *丰富* 文档，如果有需要的话，接着返回文档给协调节点。
3. 一旦所有的文档都被取回了，协调节点返回结果给客户端。




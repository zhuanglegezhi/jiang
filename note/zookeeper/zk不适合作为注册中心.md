## 固定窗口法/计数器法

计数器法是限流算法里最简单也是最容易实现的一种算法。假设我们规定接口A的qps是100， 即每分钟的访问次数不能超过100。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，初始化为0， 过期时间为1秒，即1秒后计数器失效。每当一个请求过来的时候，counter值加1，判断当前counter的值是否大于100，如果大于100则说明请求数过多，直接拒绝请求。如果请求counter计数器不存在，则重置计数器，开始新的一秒的接口限流。注意并发情况下访问计数器需要加锁。

缺点

- 限制粒度太低，存在临界问题。
  - 例如：假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在1秒内，瞬间发送了200个请求。用户通过在时间窗口的重置节点处突发请求，可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。解决这个问题的办法就是提高限流的粒度，即滑动窗口算法。





## 滑动窗口

滑动窗口的概念源于计算机网络，它的限流思想描述如下：假设一个时间窗口就是一分钟。然后我们将时间窗口进行划分，比如我们将滑动窗口划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。滑动窗口能够很好的解决计数器法所存在的临界问题，并且窗口划分粒度越细，窗口滑动就越平滑，控制效果越好。滑动窗口实现较复杂，临界问题只是某种极端案例，比如恶意攻击，是否采用这种限流方式，还需取决于具体业务的要求。





## 令牌桶算法

令牌桶算法的思路是，如果希望限制的QPS是1000。那么，就设置一个容量是1000的桶，每1/1000秒的恒定速率产生token放入桶中。每个请求达到之后，需要判断桶中是否有token。如果的话，处理请求；没有的话，拒绝服务或等待。

![img](../图片/f80c0bbf204f4fd2900f456ba2d2f2e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

在实际的开发中，因为timer的精度或效率，不一定会直接使用每1/1000秒放一个token的这种策略，比如改为1/100秒放10个token这样的策略。




## 漏桶算法

- 存在一个桶（或者队列）把请求不断放入队列中，队列的出口以一个恒定的速度出队。







## 使用redis限流










# ZAB（Zookeeper Atomic Broadcast）协议


>所有事务必须由一个 **全局唯一的服务器来协调处理** ，这样的服务器被称为Leader服务器，余下的服务器则称为Follower服务器
>
>1. Leader服务器负责将一个客户端事务请求转化为一个事务Proposal（提案），并将该Proposal分发给集群中所有的Follower服务器
>2. Leader服务器等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，Leader就会向所有的Follower服务器发送Commit消息，要求将前一个Proposal进行提交。



## 两种基本模式

### 1、崩溃恢复（选举Leader）

- ZooKeeper 选举会发生在服务器初始状态和运行状态下。
- 初始状态下会根据服务器 `sid` 的编号对比，编号越大权值越大，投票过半数即可选出 Leader。
- Leader 故障会触发新一轮选举，`zxid` 代表数据越新，权值也就越大。
- 在运行期选举还可能会遇到脑裂的情况



#### 术语

**myid：**每个 Zookeeper 服务器，都需要在数据文件夹下创建一个名为 myid 的文件，该文件包含整个 Zookeeper 集群唯一的 ID（整数）。

**zxid：**类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal ID。为了保证顺序性，该 zkid 必须单调递增。因此 Zookeeper 使用一个 64 位的数来表示，高 32 位是 Leader 的 epoch，从1开始，每次选出新的 Leader，epoch 加一。低 32 位为该 epoch 内的序号，每次 epoch 变化，都将低 32 位的序号重置。这样保证了 zkid 的全局递增性。

- 

  

####  选票数据结构

每个服务器在进行领导选举时，会发送如下关键信息：

- **logicClock：**每个服务器会维护一个自增的整数，名为 logicClock，它表示这是该服务器发起的第多少轮投票。
- **state：**当前服务器的状态。
- **self_id：**当前服务器的 myid。
- **self_zxid：**当前服务器上所保存的数据的最大 zxid。
- **vote_id：**被推举的服务器的 myid。
- **vote_zxid：**被推举的服务器上所保存的数据的最大 zxid。



#### 投票流程

**（1）自增选举轮次**

Zookeeper 规定所有有效的投票都必须在同一轮次中。每个服务器在开始新一轮投票时，会先对自己维护的`logicClock`进行自增操作。

**（2）初始化选票**

每个服务器在广播自己的选票前，会将自己的投票箱清空。该投票箱记录了所收到的选票。例：服务器 2 投票给服务器 3，服务器 3 投票给服务器 1，则服务器 1 的投票箱为(2, 3), (3, 1), (1, 1)。票箱中只会记录每一投票者的最后一票，如投票者更新自己的选票，则其它服务器收到该新选票后会在自己票箱中更新该服务器的选票。

**（3）发送初始化选票**

每个服务器最开始都是通过广播把票投给自己。

**（4）接收外部投票**

服务器会尝试从其它服务器获取投票，并记入自己的投票箱内。如果无法获取任何外部投票，则会确认自己是否与集群中其它服务器保持着有效连接。如果是，则再次发送自己的投票；如果否，则马上与之建立连接。

**（5）判断选举轮次**

收到外部投票后，首先会根据投票信息中所包含的 `logicClock` 来进行不同处理：

1. 外部投票的 logicClock**大于**自己的 logicClock。说明该服务器的选举轮次落后于其它服务器的选举轮次，立即清空自己的投票箱并将自己的 logicClock 更新为收到的 logicClock，然后再对比自己之前的投票与收到的投票以确定是否需要变更自己的投票，最终再次将自己的投票广播出去。
2. 外部投票的 logicClock**小于**自己的 logicClock。当前服务器直接忽略该投票，继续处理下一个投票。
3. 外部投票的 logickClock 与自己的**相等**。当时进行选票 PK。

**（6）选票 PK**

选票 PK 是基于 `(self_id, self_zxid)` 与 `(vote_id, vote_zxid)` 的对比：

- 外部投票的 logicClock**大于**自己的 logicClock，则将自己的 logicClock 及自己的选票的 logicClock 变更为收到的 logicClock。
- 若`logicClock`一致，则对比二者的 vote_zxid，若外部投票的 vote_zxid 比较大，则将自己的票中的 vote_zxid 与 vote_myid 更新为收到的票中的 vote_zxid 与 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。如果票箱内已存在(self_myid, self_zxid)相同的选票，则直接覆盖。
- 若二者**vote_zxid**一致，则比较二者的 vote_myid，若外部投票的 vote_myid 比较大，则将自己的票中的 vote_myid 更新为收到的票中的 vote_myid 并广播出去，另外将收到的票及自己更新后的票放入自己的票箱。

**（7）统计选票**

如果已经确定有过半服务器认可了自己的投票（可能是更新后的投票），则终止投票。否则继续接收其它服务器的投票。

**（8）更新服务器状态**

投票终止后，服务器开始更新自身状态。若过半的票投给了自己，则将自己的服务器状态更新为 LEADING，否则将自己的状态更新为 FOLLOWING。

**总结**

```
1、通过以上流程分析，我们不难看出：要使 Leader 获得多数 Server 的支持，则 ZooKeeper 集群节点数必须是奇数。且存活的节点数目不得少于 N + 1。
2、每个 Server 启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的 server 还会从磁盘快照中恢复数据和会话信息，zk 会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。
```



>https://dbaplus.cn/news-141-1875-1.html
>
>脑裂：https://juejin.cn/post/6844903895387340813



### 2、原子广播

1）在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中数据副本的同步方式**与二阶段提交相似**，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。

2）Zab协议中 Leader 等待 Follower 的ACK反馈消息是指"**只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈**"

> https://www.huaweicloud.com/articles/b696779df9cf3272db9695a83efae29f.html





## 节点状态

- **LOOKING**：Leader选举阶段

- **FOLLOWING：**跟随者状态。表明当前服务器角色是 Follower，并且它知道 Leader 是谁。

- **LEADING：**领导者状态。表明当前服务器角色是 Leader，它会维护与 Follower 间的心跳。

  
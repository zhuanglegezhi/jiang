**MyISAM引擎不支持事务**



# ACID

事务是由一组SQL语句组成的逻辑处理单元，事务具有4属性，通常称为事务的ACID属性。

- **原子性（Actomicity）**：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

- **一致性（Consistent）**：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。

- **隔离性（Isolation**）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。

- **持久性（Durable**）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。



# 隔离性

### 术语

**脏读**

脏读指的是读到了其他事务未提交的数据，这就是脏读。

**可重复读**

可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据都是一致的。

**不可重复读**

对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。

**幻读**

假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。



### 隔离级别

1. 读未提交（READ UNCOMMITTED）
   - 没有加任何锁，也就是没任何隔离
2. 读提交 （READ COMMITTED）
3. 可重复读 （REPEATABLE READ）
4. 串行化 （SERIALIZABLE）
   - 读的时候加共享锁；写的时候加排他锁，其他事务不能并发写也不能并发读

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，**可重复读**是 MySQL 的默认级别。

![img](https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_1440w.jpg)




#### mvvc 

原理：undo log + read view

限制：MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容，因为 READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

InnoDB中通过undo log实现了数据的多版本，而并发控制通过锁来实现。

InnoDB存储引擎在数据库每行数据的后面添加了三个字段

- 6字节的事务ID(DB_TRX_ID)字段：用来标识最近一次对本行记录做修改(insert|update)的事务的标识符，即最后一次修改(insert|update)本行记录的事务id。至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted，并非真正删除。

- 7字节的回滚指针(DB_ROLL_PTR)字段：指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。

- 6字节的DB_ROW_ID字段：包含一个随着新行插入而单调递增的行ID，当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。

  

![img](https://pic1.zhimg.com/80/v2-114dd6691636883a92e7c1060210a014_1440w.jpg)

**快照****（ReadView）**

1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；



**READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 `ReadView` 的时机不同。**

- 在 READ COMMITTED 中`每次查询`都会生成一个实时的 ReadView，做到保证每次提交后的数据是处于当前的可见状态。
- 而 REPEATABLE READ 中，在当前事务`第一次查询时`生成当前的 ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读（REPEATABLE READ）。
  
  



>https://zhuanlan.zhihu.com/p/117476959
>
>https://zhuanlan.zhihu.com/p/66791480
>


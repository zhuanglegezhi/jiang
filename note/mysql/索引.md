## 索引的数据结构

1. **Hash**

   **不适合**，可以快速的精确查询，但是不支持范围查询

2. **二叉查找树**

   **不适合**，可能会有树退化到链表的问题，当然，效率也很低，磁盘IO过多

3. **平衡二叉树**

   问题：

   1. 时间复杂度和树高相关。树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。磁盘每次寻道时间为10ms，在表数据量大时，查询性能就会很差。
   2. 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高。

   **不适合**

   

> MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作。访问二叉树的每个节点就会发生一次IO，如果想要减少磁盘IO操作，就需要尽量降低树的高度。那如何降低树的高度呢？


4. **B树**

   缺点：

   1. B树不支持范围查询的快速查找，你想想这么一个情况如果我们想要查找10和35之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
   2. 如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。这时，一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。

5. **B+树**

   - B树的升级版

   - B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会**冗余**一份在叶子节点中（好处：**为了提高范围查找的效率**），并且叶子节点之间用指针相连
   
   - 叶子结点层使用双向链表，保证范围查询效率
   
   

## 索引类型

1. 主键索引

   索引列中的值必须是唯一的，不允许有空值。

2. 普通索引
   MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。

3. 唯一索引
   索引列中的值必须是唯一的，但是允许为空值。

4. 全文索引
   只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。

5. 空间索引
   MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。

6. 前缀索引
   在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

7. 其他（按照索引列数量分类）
   单列索引

​       组合索引

​      组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情况下使用组合索引替代多个单列索引使用



## 聚簇索引

- myisam是非聚簇索引（**叶子结点存放的不是id，而是数据地址**），innodb是聚簇索引

  ![image-20211005190552780](/Users/zz/Library/Application Support/typora-user-images/image-20211005190552780.png)

- B+树是左小右大的顺序存储结构，非叶子节点只包含id索引列，而叶子节点包含索引列和数据，这种**数据和索引在一起存储**的索引方式叫做聚簇索引



## 页

> Q：那么，一个B+树的节点中到底存多少个元素最合适？
>
> A：**B+树中一个节点为一页或页的倍数最为合适**。

因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。

如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。

所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。



## 回表

回到主键索引树搜索的过程，就是**回表**。不过也有方法避免回表，那就是**覆盖索引**。



## 覆盖索引

这个其实比较好理解，刚才我们是 select * ，查询所有的，我们如果只查询ID那，其实在Name字段的索引上就已经有了，那就不需要回表了。

覆盖索引可以减少树的搜索次数，提升性能，他也是我们在实际开发过程中经常用来优化查询效率的手段。



## 最左匹配原则

- 索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，**遇到范围查询 (>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找**。
- 因此，**列的排列顺序决定了可命中索引的列数**。

例子：

- 如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)



## 总结

优势

- 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
- **被索引的列会自动进行排序**，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
- 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。

劣势

- 索引会占据磁盘空间
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。





> https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg（写的很好）


## 1、乐观锁

认为一个用户读数据的时候，别人不会去写自己所读的数据；

实现方式

- 版本号

- 时间戳

  

## 2、悲观锁

就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；



#### 表锁

开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。



#### 页级锁

开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般



#### 行锁

开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。



- **共享锁**：

  - **概念**：S锁，也叫读锁，用于所有的只读数据操作。共享锁是非独占的，允许多个并发事务读取其锁定的资源。 `xxx lock in share mode`

  - **加锁与解锁**：当一个事务执行select语句时，数据库系统会为这个事务分配一把共享锁，来锁定被查询的数据。在默认情况下，数据被读取后，数据库系统立即解除共享锁。例如，当一个事务执行查询“SELECT * FROM accounts”语句时，数据库系统首先锁定第一行，读取之后，解除对第一行的锁定，然后锁定第二行。这样，在一个事务读操作过程中，允许其他事务同时更新accounts表中未锁定的行。

  - **兼容性**：如果数据资源上放置了共享锁，还能再放置共享锁和更新锁。

  - **并发性能**：具有良好的并发性能，当数据被放置共享锁后，还可以再放置共享锁或更新锁。所以并发性能很好。

- **排他锁**：

  - **概念**：X锁，也叫写锁，表示对数据进行写操作。如果一个事务对对象加了排他锁，其他事务就不能再给它加任何锁了。`xxx for update`

  - **加锁与解锁**：当一个事务执行insert、update或delete语句时，数据库系统会自动对SQL语句操纵的数据资源使用独占锁。如果该数据资源已经有其他锁（任何锁）存在时，就无法对其再放置独占锁了。
  - **兼容性**：独占锁不能和其他锁兼容，如果数据资源上已经加了独占锁，就不能再放置其他的锁了。同样，如果数据资源上已经放置了其他锁，那么也就不能再放置独占锁了。
  - **并发性能**：最差。只允许一个事务访问锁定的数据，如果其他事务也需要访问该数据，就必须等待。



#### MyISAM

支持表级锁

#### InnoDB

InnoDB 支持表锁、行锁，实际上InnoDB 是通过给索引项加锁，来实现行锁的。

只有查询数据时，检索条件走索引才可以使用行级锁，否则 InnoDB 将使用表锁。





死锁
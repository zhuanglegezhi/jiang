# 1.G1 (Garbage-First Garbage Collector)

#### Region

传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代（JDK 8去除了永久代，引入了元空间Metaspace），这种划分的特点是各代的存储地址（逻辑地址，下同）**是连续**的。如下图所示：

![传统GC内存布局](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8a9db36e.png)

而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。如下图所示：

![g1 GC内存布局](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8ca16868.png)

在上图中，我们注意到还有一些Region标明了H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象。H-obj有如下几个特征： 

- H-obj直接分配到了old gen，防止了反复拷贝移动。 
- H-obj在global concurrent marking阶段的cleanup 和 full GC阶段回收。
- 在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC。

### SATB

全称是Snapshot-At-The-Beginning，由字面理解，是GC开始时活着的对象的一个快照。它是通过Root Tracing得到的，作用是维持并发GC的正确性。 那么它是怎么维持并发GC的正确性的呢？

根据**三色标记**算法，我们知道对象存在三种状态： 

- 白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。 
- 灰：对象被标记了，但是它的field还没有被标记或标记完。 
- 黑：对象被标记了，且它的所有field也被标记完了



#### YGC

选定**所有**年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销



#### Mixed GC

- 选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。
- Mixed GC不是full GC，它只能回收部分老年代的Region，如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。



#### RememberedSet




### Refer

>https://tech.meituan.com/2016/09/23/g1.html



